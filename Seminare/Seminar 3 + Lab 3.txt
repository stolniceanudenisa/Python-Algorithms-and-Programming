https://github.com/AP-MI-2021?q=lab-5&type=all&language=&sort=


https://github.com/boldijar/babes-info-romana/tree/master/Fundamentele%20programarii

https://github.com/dorismoisuc/Programming-Fundamentals/tree/master/Assignment3-4
https://github.com/flaviu2001/University-Projects
https://github.com/carinaghiorghita/UBB_Sem1_FP

https://github.com/donpaul999/UBB/tree/master/Year%201/Semester%201/python/Assignments












def show_menu():
    print("1. Citire numere din lista ")
    print("2. Afisare secventa in care in oricare trei elemente consecutive exista o valoare care se repeta.")
    print("3. Afisare secventa in care diferentele (x[j+1] - x[j]) si (x[j+2] - x[j+1]) au semne contrare.")
    print("4. Iesire")


def read_list1():
    l = []
    linie = input("Dati numerele din lista, separate printr-un spatiu: ")
    numere = linie.split(" ")
    for nr in numere:
        l.append(int(nr))
    return l


def read_list2():
    l = []
    n = int(input("Dati numarul de elemente al listei: "))
    for i in range(n):
        l = l + [int(input("Dati elementele din lista: "))]
    return l


def sir_crescator(lst):
    '''
    Verifica daca un sir este crescator.
    :param: Lista de numere
    :return: True dacaa sirul este crescator, fals in caz contrar.
    '''
    for i in range(len(lst)-1):
        if lst[i+1] < lst[i]:
            return False
    return True

def sir_descrescator(lst):
    '''
    Verifica daca un sir este crescator.
    :param: Lista de numere
    :return: True dacaa sirul este crescator, fals in caz contrar.
    '''
    for i in range(len(lst)-1):
        if lst[i+1] > lst[i]:
            return False
    return True


def semnElement(x):
    '''
    Determina semnul unui element.
    :param x:
    :return: true semnul +, false semnul -
    '''
    if x < 0:
        return True
    else:
        return False


def egale(x, y):
    """
    Determina daca doua elemente sunt egale.
    :param Cele doua elemente:
    :return True daca elementele sunt egale, False in caz contrar:
    """
    if x == y:
        return True
    return False


def verifegale(lst):
    """
    Determina daca numerele din lista au valori egale 3 cate 3
    :param lst:
    :return True sau False:
    """
    if len(lst) > 1:
        for i in range(0, len(lst) - 2):
            if egale(lst[i],lst[i+1]) == egale(lst[i+1],lst[i+2]) == egale(lst[i],lst[i+2]):
                return False
    return True


def totegal(lst):
    if len(lst) > 1:
        for i in range(0, len(lst)):
            if lst[0] != lst[i]:
                return False
    return True


def cea_mai_lunga_nr_consec(lst):
    """
    Determina cea mai lunga subsecventa de numere in care in oricare trei elemente consecutive exista o valoare care se repeta.
    :param lst - lista de numere:
    :return lista cu cea mai lunga subsecventa cu proprietatea ceruta:
    """
    subsecventaMax2 = []
    if sir_crescator(lst) == True or  sir_descrescator(lst) == True:
        return subsecventaMax2
    for i in range(len(lst)):
        for j in range(len(lst)):
            if verifegale(lst[i:j + 1]) and len(lst[i:j + 1]) > len(subsecventaMax2):
                subsecventaMax2 = lst[i:j + 1]
    return subsecventaMax2


def test_toate_semnele_egale():
    assert cea_mai_lunga_nr_consec([1, 2, 3, 4, 5, 6]) == []
    assert cea_mai_lunga_nr_consec([1, 2, 2, 3, 5, 6, 7, 8, 2, 2, 3]) == [1, 2, 2, 3]
    assert cea_mai_lunga_nr_consec([20, 19, 13, 5, 4, 2, 0]) == []
    assert cea_mai_lunga_nr_consec([3, 4, 3, 3, 5, 3, 6, 7]) == [3, 4, 3, 3, 5, 3]
    assert cea_mai_lunga_nr_consec([2, 4, 5, 3, 3, 4, 3, 3, 2, 3, 3, 3, 3, 8, 9]) == [5, 3, 3, 4, 3, 3, 2, 3, 3]


def toateSemneleAlternante(lst):
    """
    Determina daca numerele din lista au semnul alternant sau nu
    :param lst:
    :return True sau False:
    """
    if len(lst) > 1:
        for i in range(0, len(lst) - 2):
            if semnElement(lst[i+1]-lst[i]) == semnElement(lst[i + 2]-lst[i+1]):
                return False
    return True


def get_longest_alternating_signs(lst):
    """
    Determina cea mai lunga subsecventa de numere a caror diferenta are semne alternante
    :param lst - lista de numere:
    :return lista cu cea mai lunga subsecventa de numere a caror diferenta are semne alternante:
    """
    subsecventaMax2 = []
    for i in range(len(lst)):
        for j in range(len(lst)):
            if toateSemneleAlternante(lst[i:j + 1]) and len(lst[i:j + 1]) > len(subsecventaMax2):
                subsecventaMax2 = lst[i:j + 1]
    return subsecventaMax2


def test_get_longest_alternating_signs():
    assert get_longest_alternating_signs([1, 3, 2, 7, 5]) == [1, 3, 2, 7, 5]
    assert get_longest_alternating_signs([8, 3, 10, 11, 12]) == [8, 3, 10]
    assert get_longest_alternating_signs([1, 4, 2, 8, 4, 5]) == [1, 4, 2, 8, 4, 5]
    assert get_longest_alternating_signs([4, 7, 5, 9, 2, 13, 4, 5, 6, 7]) == [4, 7, 5, 9, 2, 13, 4, 5]
    assert get_longest_alternating_signs([100, 45, 10, 11, 4, 22, 10, 16, 6, 12]) == [45, 10, 11, 4, 22, 10, 16, 6, 12]


def main():
    l = []
    while True:
        show_menu()
        optiune = input("Dati optiunea: ")
        if optiune == '1':
            l = read_list1()
        elif optiune == '2':
            if sir_crescator(l) == False:
                l2 = cea_mai_lunga_nr_consec(l)
                print('Afisare secventa in care exista o valoare care se repeta', l2[:])
            elif totegal(l) == True:
                print('Toate elementele din secventa sunt egale:', l[:])
            else:
                print('Elementele sunt ordonate crescator. Nu exista subsecventa ceruta. ')
        elif optiune == '3':
            if sir_crescator(l) == False:
                l2 = get_longest_alternating_signs(l)
                print('Afisare secventa in care diferentele au semne contrare', l2[:])
            elif totegal(l) == True:
                print('Toate elementele din secventa sunt egale:', l[0])
            else:
                print('Elementele sunt ordonate crescator. Nu exista subsecventa ceruta.')
        elif optiune == '4':
            break
        else:
            print("Optiune invalida.Reincercati.")


if __name__ == '__main__':
    test_toate_semnele_egale()
    test_get_longest_alternating_signs()
    main()























https://github.com/AP-MI-2021?q=lab-3&type=all&language=&sort=
https://github.com/teodoraalexandra/Fundamental-Of-Programming
https://github.com/alexandrustoica/ubb-master
https://github.com/RazvanFarte/academic-info



https://github.com/lauradiosan/AI-UBB

https://github.com/Taveeh/University

https://github.com/iuliagroza/Uni-Stuff-Babes-Bolyai-University-
https://github.com/teofanaenachioiu/University-Courses
https://github.com/nikitautiu/ubb
https://github.com/viorelyo/2048_UBB_Edition
https://github.com/imimali/MFPC
https://github.com/viorelyo/ExtWatcher
https://github.com/cristicretu/cplusplus
https://github.com/teofanaenachioiu/University-Courses
https://github.com/rusucosmin/courses
https://github.com/Pufcorina/Fundamental-of-Programming/tree/master/Courses

https://github.com/alexnaiman/Fundamentals-Of-Programming---Lab-assignments

https://github.com/alexovidiupopa/UBB

https://github.com/topics/ubb-computer-science
https://www.geeksforgeeks.org/python-print-sublists-list/
https://www.geeksforgeeks.org/python-check-values-list-greater-given-value/
https://www.geeksforgeeks.org/longest-subarray-with-elements-having-equal-modulo-k/

https://www.youtube.com/results?search_query=longest+subarray+with+all+elementes+the+same+phyton



Seminar 3

https://github.com/AP-MI-2021/seminar-3-ClaudiuDC21

https://github.com/AP-MI-2021/Lab-4







sem 4-5-6
https://github.com/AP-MI-2021/seminar-456-ClaudiuDC21






#Determine the age of a person, in number of days.
#We know that a normal year has 365 calendar days, and every 4 years, a year has 366 calendar days.
#Therefore, we can say that for n the age in years, the age in days would be equal to n*365 + [n/4], where 
#"[]" denotes the mathematical function floor. 

import math
age = int(input("Your age in years is:"))
print("And your age in days is(roughly):",age*365+math.floor(age/4), "days")







#Determine a calendar data (as year, month, day) starting from two integer numbers representing the year and the day number inside that year.


def isLeap(year):
    if year % 4 == 0 : 
        return True
    return False

def solve():
    year = int(input("Tell me the year:"))
    dayNumber = int(input("...and the day number:"))
    daysInAYear=365
    if isLeap(year):
        daysInAYear += 1
    if dayNumber > daysInAYear or dayNumber <= 0: 
        print("Oops, the day number is not in the current year! Please tell me a date from this year: ")
        dayNumber = int(input())
     






3.Determina o data calendaristica (sub forma an, luna, zi) pornind de
la doua numere întregi care reprezintă anul si numărul
de ordine al zilei in anul respectiv.

'''
    descriere - Determina o data calendaristica (sub forma an, luna, zi) pornind de
    la doua numere întregi care reprezintă anul si numărul de ordine al zilei in anul respectiv.
    input - anul si numarul de ordine al zilei.
    output - o data calendaristica (sub forma an, luna, zi)
'''

def an_bisect(anul):
    if anul % 4 == 0:
        return True
    return False

An = int(input("Dati anul de nastere: "))
nr_ordine_zi = int(input("Dati numarul de ordine al zilei din an: "))

#ex:  70 70//30==2 70%30==10
if nr_ordine_zi > 365 or nr_ordine_zi <= 0:
    print("Numărul zilei nu este în anul curent! Introduceti alt numar de ordine al zilei.")
else:
    print(str(An),".",nr_ordine_zi // 30,".",nr_ordine_zi % 30)









sau


# Determina o data calendaristica (sub forma an, luna, zi) pornind de
# la doua numere întregi care reprezintă anul si numărul
# de ordine al zilei in anul respectiv.

import datetime

a = int(input("Anul: "))
z = int(input("Ziua de ordin: "))

x = datetime.datetime(a, 1, 1) + datetime.timedelta(z-1)

print(x.strftime("%Y"), ".", x.strftime("%b"), ".", x.strftime("%d"), sep = "")



'''
    descriere - Determina o data calendaristica (sub forma an, luna, zi) pornind de
    la doua numere întregi care reprezintă anul si numărul de ordine al zilei in anul respectiv.
    input - anul si numarul de ordine al zilei.
    output - o data calendaristica (sub forma an, luna, zi)
'''

def an_bisect(anul):
    if anul % 4 == 0:
        return True
    return False

An = int(input("Dati anul de nastere: "))
nr_ordine_zi = int(input("Dati numarul de ordine al zilei din an: "))

#ex:  70 70//30==2 70%30==10
if nr_ordine_zi > 365 or nr_ordine_zi <= 0:
    print("Numărul zilei nu este în anul curent! Introduceti alt numar de ordine al zilei.")
else:
    print(str(An),".",nr_ordine_zi // 30,".",nr_ordine_zi % 30)



 




https://github.com/alexovidiupopa/Fundamentals-of-Programming-/blob/master/A02/Program


def sequence_numbers_strictly_increasing_real_part(listOfNumbers):
    '''
    The "set" function for the first sequence
    Input: "listOfNumbers"-the tuple of complex numbers already read by the user
    Output: the function will print the required sequence, and then return. 
    Remarks: -To solve the problem, we will use the algorithm for finding the longest sequence on the first search through the listOfNumbers
            -If there are two sequences of the same maximum length, the first one in the listOfNumbers will be printed. 
    Restrictions: In the listOfNumbers, the real part of the number is always on positions 0,2,4,...,n-2; and the imaginary part of the number is always on positions 1,3,..,n-1
    Exceptions: if the listOfNumbers is empty, the function won't print anything, telling the user he/she needs to enter some numbers first.
    '''
    if not listOfNumbers :
        exception()
        return 0
    lengthOflistOfNumbers = len(listOfNumbers)
    sequence = []
    maxLength = 0
    currentLength = 1
    startPosition = 0 
    for i in range (1,lengthOflistOfNumbers):
        if getReal(listOfNumbers[i])>getReal(listOfNumbers[i-1]):
            currentLength+=1
        else:
            if currentLength>maxLength:
                maxLength = currentLength
                startPosition = i - maxLength
            currentLength = 1 
    if currentLength>maxLength:
        maxLength = currentLength
        startPosition = lengthOflistOfNumbers - maxLength
    #sequenceIndex = 0
    for i in range(startPosition,startPosition+maxLength):
        add_complex(listOfNumbers[i],sequence)
    return sequence






















Tema mea 9+10


def show_menu():
    print("1. Citire numere din lista ")
    print("2. Afisare secventa in care in oricare trei elemente consecutive exista o valoare care se repeta.")
    print("3. Afisare secventa in care diferentele (x[j+1] - x[j]) si (x[j+2] - x[j+1]) au semne contrare.")
    print("x. Iesire")


def read_list1():
    l = []
    linie = input("Dati numerele din lista, separate printr-un spatiu: ")
    numere = linie.split(" ")
    for nr in numere:
        l.append(int(nr))
    return l


def read_list2():
    l = []
    n = int(input("Dati numarul de elemente al listei: "))





def semnElement(x):
    '''
    Determina semnul unui element.
    :param x:
    :return: true semnul +, false semnul -
    '''
    if x < 0:
        return True
    else:
        return False


def toateSemneleAlternante(lst):
    """
    Determina daca numerele din lista au semnul alternant sau nu
    :param lst:
    :return True sau False:
    """
    if len(lst) > 1:
        for i in range(0, len(lst) - 1):
            if semnElement(lst[i]) == semnElement(lst[i + 1]):
                return False
    return True


def get_longest_alternating_signs(lst: list[int]):
    """
    Determina cea mai lunga subsecventa de numere a caror diferenta are semne alternante
    :param lst - lista de numere:
    :return lista cu cea mai lunga subsecventa de numere a caror diferenta are semne alternante:
    """
    subsecventaMax2 = []
    for i in range(len(lst)):
        for j in range(len(lst)):
            if toateSemneleAlternante(lst[i:j + 1]) and len(lst[i:j + 1]) > len(subsecventaMax2):
                subsecventaMax2 = lst[i:j + 1]
    return subsecventaMax2


def test_get_longest_alternating_signs():
    assert get_longest_alternating_signs([-3, 3, -3, 7, 9]) == [-3, 3, -3, 7]
    assert get_longest_alternating_signs([7, 8, 9, 10]) == [7]
    assert get_longest_alternating_signs([7, 8, -4, 9, -5, 3, 9, -4]) == [8, -4, 9, -5, 3]


def main():
    l = []
    while True:
        show_menu()
        optiune = input("Dati optiunea: ")
        if optiune == '1':
            l = read_list1()
        elif optiune == '2':
            print(l)
        elif optiune == '3':
            l2 = get_longest_alternating_signs(l)
            print('Afisare secventa in care diferentele au semne contrare', l2[:])
        elif optiune == 'x':
            break
        else:
            print("Optiune invalida.Reincercati.")

if __name__ == '__main__':
    test_get_longest_alternating_signs()
    main()























------------------------------------------------------------------------



from typing import List


def show_menu():
    print('1. Citire lista de numere intregi')
    print('2. Determina cea mai lunga subsecvența in care intre oricare 3 elemente consecutive exista o valoare care se repeta')
    print('3. Determina cea mai lunga subsecventa in care diferentele x[j+1] - x[j] si x[j+2] - x[j+1] au semne contrare')
    print('x. Iesire')


def read_list():
    lst = []
    lst_str = input('Dati numerele separate prin spatiu: ')
    lst_str_split = lst_str.split(' ')
    for num_str in lst_str_split:
        lst.append(int(num_str))
    return lst



def cea_mai_lunga_elem_consec_val_repetata(lst: List[int]) -> List[int]:
    '''
    Determina cea mai lunga subsecvența in care intre oricare 3 elemente consecutive exista o valoare care se repeta.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''


#??????????????????????????????????????????








---- semne alternante
https://github.com/AP-MI-2021/lab-3-Fexort/blob/main/main.py


def cea_mai_lunga_subsecventa_semne_contrare(lst: List[int]) -> List[int]:
    '''
    Determina cea mai lunga subsecventa in care diferentele (x[j+1] - x[j]) si (x[j+2] - x[j+1]) au semne contrare.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''
    n = len(lst)
    result = []
    lmax = 0
    lc = 0
    pc = 0
    pmax = 0
    for i in range(n):
        if lst[i+1] - lst[i] < 0 and lst[i+2] - lst[i+1] > 0 or lst[i+1] - lst[i] > 0 and lst[i+2] - lst[i+1] < 0:
            lc+=2 # ?????? din cat in cat
            dif1 = lst[i+1] - lst[i]
            dif2 = lst[i+2] - lst[i+1]
        elif (lst[i+1] - lst[i] < 0 and lst[i+2] - lst[i+1] < 0) or lst[i+1] - lst[i] > 0 and lst[i+2] - lst[i+1] > 0:
            if lc > lmax:
                lmax = lc
                pmax = pc
            lc = 1
            pc = i
    for j in range(pmax, pmax+lmax+1):
        print(lst[j])
    #return result


def semne_contrare(lst):
 

   


def main():
    lst = []
    while True:
        show_menu()
        optiune = input('Optiunea: ')
        if optiune == '1':
            lst = read_list()
        elif optiune == '2':
            primes = get_primes(lst)
            print('Numerele prime din lista sunt:', primes)
        elif optiune == '3':
            print('Cea mai lunga subsecventa cu semne contrare: ', cea_mai_lunga_subsecventa_semne_contrare(lst))
        elif optiune == 'x':
            break
        else:
            print('Optiune invalida. ')


if __name__ == '__main__':
    test_is_prime()
    main()







---------------------------------------
prop 1

# [i] < x[i+1] < ... < x[i+p]
# crescator

def citire():
    l = []
    n = int(input())
    for i in range(n):
        l = l + [int(input())]
    return l


def lungscv():
    l = citire()
    ok = 1
    c = 1
    cmax = 0
    for i in range(len(l) - 1):
        if l[i] < l[i + 1]:
            c += 1

        else:
            if (cmax < c):
                cmax = c
                pmax = i
            p = pmax - c + 1
            c = 1
    if (c != 1):
        if (cmax < c):
            cmax = c

    return l[p:pmax + 1]


def main():
    print(lungscv())

if __name__ == '__main__':
    main()







prop 3

+ asserturi


def cmmdc(a, b):
    if a == 0: return b
    if b == 0: return a
    while a != b:
        if a > b:
            a = a - b
        else:
            b = b - a
    return a


def citire():
    l = []
    n = int(input())
    for i in range(n):
        l = l + [int(input())]
    return l


def lungscv():
    # l=citire()
    l = [1, 3, 7, 2, 7, 7, 7, 2, 3, 11, 10, 11, 12]
    ok = 1
    c = 1
    cmax = pmin = pmax = 0
    for i in range(len(l) - 1):
        if cmmdc(l[i], l[i + 1]) == 1:
            c += 1
        else:
            if (cmax < c):
                cmax = c
                pmax = i - c + 1
                ok = 0
            c = 1
    if (cmax < c):
        cmax = c
        pmax = i - cmax + 1
    return l[pmax + 1:pmax + cmax + 1]


def main():
    print(lungscv())


main()




----------------
prop 2-6


from typing import List


def show_menu():
    print('1. Citire lista de numere intregi')
    print('2. x[i] < x[i+1] < ... < x[i+p]')
    print('3. Oricare doua elemente consecutive sunt relativ prime intre ele (a, b relativ prime daca si numai daca cmmdc(a,b) = 1).')
    print('4. Determina cea mai lunga subsecvența ce contine doar numere prime.')
    print('5. Determina cea mai lunga subsecventa care are toate elementele egale.')
    print('6. Determina cea mai lunga subsecvența in care sunt toate elementele distincte intre ele')
    print('x. Iesire')


def read_list():
    lst = []
    lst_str = input('Dati numerele separate prin spatiu: ')
    lst_str_split = lst_str.split(' ')
    for num_str in lst_str_split:
        lst.append(int(num_str))
    return lst


def prima_prop():
    lst = read_list()
    c = 1
    cmax = 0
    for i in range(len(lst) - 1):
        if lst[i] < lst[i + 1]:
            c += 1
        else:
            if (cmax < c):
                cmax = c
                pmax = i
            p = pmax - c + 1
            c = 1
    if (c != 1):
           if (cmax < c):
            cmax = c
    return lst[p:pmax + 1]



def cea_mai_lunga_secv_contine_doar_nrprime(lst: List[int]) -> List[int]:
    '''
    Determina cea mai lunga subsecvența ce contine doar din numere prime.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''
    n = len(lst)
    result = []
    for st in range(n):
        for dr in range(st, n):
            all_is_prime = True
            for num in lst[st:dr + 1]:
                if is_prime(num) != True:
                    all_is_prime = False
                    break
            if all_is_prime:
                if dr - st + 1 > len(result):
                    result = lst[st:dr + 1]
    return result


def cea_mai_lunga_secv_care_are_toate_el_egale(lst):
    '''
    Determina cea mai lunga subsecventa care are toate elementele egale.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''
    n = len(lst)
    lc=1
    pmax=0
    lmax=1
    pc=0
    for i in range(n):
        if lst[i]==lst[i+1]:
            lc+=1
    return lc


def cea_mai_lunga_subsecventa_semne_contrare(lst: List[int]) -> List[int]:
    '''
    Determina cea mai lunga subsecventa in care diferentele (x[j+1] - x[j]) si (x[j+2] - x[j+1]) au semne contrare.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''
    n = len(lst)
    result = []
    lmax = 0
    lc = 0
    pc = 0
    pmax = 0
    for i in range(n):
        if lst[i+1] - lst[i] < 0 and lst[i+2] - lst[i+1] > 0 or lst[i+1] - lst[i] > 0 and lst[i+2] - lst[i+1] < 0:
            lc+=2 # ?????? din cat in cat
            dif1 = lst[i+1] - lst[i]
            dif2 = lst[i+2] - lst[i+1]
        elif (lst[i+1] - lst[i] < 0 and lst[i+2] - lst[i+1] < 0) or lst[i+1] - lst[i] > 0 and lst[i+2] - lst[i+1] > 0:
            if lc > lmax:
                lmax = lc
                pmax = pc
            lc = 1
            pc = i
    for j in range(pmax, pmax+lmax+1):
        print(lst[j])
    #return result


def semne_contrare(lst):
    '''
    Determina semnul diferentei a doua numere consecutive dintr-o lista.
    :param:----------------
    :return: ----------------
    '''


def is_prime(n: int) -> bool:
    '''
    Determina daca un numar dat este prim.
    :param n: numarul dat
    :return: True daca numarul e prim si False altfel
    '''
    if n < 2:
        return False
    for d in range(2, int(n ** 0.5) + 1): # +1 ca sa ia si radicalul in sine
        if n % d == 0:                    # pt ca range(a,b) merge pana la mai mic strict decat b
            return False
    return True


def test_is_prime():
    assert is_prime(1) == False
    assert is_prime(2) == True
    assert is_prime(4) == False
    assert is_prime(15) == False
    assert is_prime(29) == True


def get_primes(lst):
    '''
    Determina numerele prime dintr-o lista.
    :param lst: lista de numere.
    :return: o lista cu numerele prime din lst.
    '''
    result = []
    for num in lst:
        if is_prime(num):
            result.append(num)
    return result


def get_longest_subarray_all_divisible_by_10(lst: List[int]) -> List[int]:
    '''
    Determina cea mai lunga subsecventa in care toate elementele sunt divizibile cu 10.
    :param lst: lista in care se cauta subsecventa
    :return: subsecventa gasita
    '''
    n = len(lst)
    result = []
    for st in range(n):
        for dr in range(st, n):
            all_div_10 = True
            for num in lst[st:dr+1]:
                if num % 10 != 0:
                    all_div_10 = False
                    break
            if all_div_10:
                if dr - st + 1 > len(result):
                    result = lst[st:dr+1]
    return result


def main():
    lst = []
    while True:
        show_menu()
        optiune = input('Optiunea: ')
        if optiune == '1':
            lst = read_list()
        elif optiune == '2':
            print('x[i] < x[i+1] < ... < x[i+p] este:', prima_prop())
        elif optiune == '4':
            print('Cea mai lunga subsecvența cu numere prime este:', cea_mai_lunga_secv_contine_doar_nrprime(lst))
        elif optiune == '5':
            print('Cea mai lunga subsecventa care are toate elementele egale este: ', cea_mai_lunga_secv_care_are_toate_el_egale(lst))
        elif optiune == '6':
            print('Cea mai lunga subsecvența in care sunt toate elementele distincte intre ele este: ', cea_mai_lunga_subsecventa_semne_contrare(lst))
        elif optiune == 'x':
            break
        else:
            print('Optiune invalida. ')


if __name__ == '__main__':
    test_is_prime()
    main()









--------------


import operator

a = [1,2,3,4,5]
size = len(a)

def p1(a):
    #returneaza lista oglindita
    #a.reverse()
    a = a[::-1]
    return a

print(p1(a))


def test_p1():
    assert p1([]) == []
    assert p1([1, 2, 5]) == [5, 2, 1]
    assert p1(["ana", "are", "mere"]) == ["mere", "are", "ana"]
    assert p1("roxana") == "anaxor"
    assert p1([1, [2,3], [4,5,6]]) == [[4,5,6], [2,3], 1]
    assert p1([1, "a", 5]) == [5, "a", 1]


test_p1()

a = [1,2,3,4,5]
b = ["a", "b", "c", "d","e"]
c =[1,"a", 2,"b", 3,"c", 4,"d", 5,"e"]


def p2(a,b):
    lista=[]
    for x,y in zip(a,b):
        lista.append(str(x)+y)
    return lista


def test_p2():
    assert p2([1,2,3],["unu", "doi", "trei"]) == ["1unu", "2doi", "3trei"]
    #assert p2([], [4,5,6]) == [4,5,6]


test_p2()


def p3(list, p):
    while p in list:
        list.remove(p)
    return list

print(p3([1,2,35,2,2,5,6,72,2,2,8],2))

def test_p3():
    assert p3([1,2,2,3,4], 2) == [1,3,4]
    assert p3([], 4) == []
    assert p3(["a", "a", "b"], "a") == ["b"]
    assert p3([1,3], 2) == [1,3]

test_p3()


def p4(lista):
    return tuple(lista)

#[1,2,3] = (1,2,3)

  #      0       1
dict = {"Key1":1,"Key2":2}
a = dict.items() #-> ("Key1", val1), ("Key2", val2)


def p5(dict):  #sortare de dictionar
    dict_out = sorted(dict.items(), Key=operator.itemgetter(1)) # dupa valoare


def test_p5():
    assert p5({1:2, 3:4, 4:3, 2:1, 0:0}) == {0:0, 2:1, 1:2, 4:3, 3:4}
    #00 12 21 34 43 (in functie de 0)


def p6(dict,Key,val) #schimbare/inlocuire valoare din dictionar de la cheia key
    for d in dict: #d ia doar cheia ///////// daca punem .items ia si valoarea -> se face tuplu
        if d == Key
            dict[Key] = val
            #{0:0, 1:2}
            #{0:9, 1:2}
    return dict

#val2 = dict[Key]
'''
    for d in dict.items():
        Key = d[0]
        val = d[1]
 '''

def test_p6():
    assert p6({1:1, 2:2},2 ,9) == {1:1, 2:9}       # la cheia 2 se schimba cu 9  /// schimbam valoarea de la cheia 2 cu 9
































